{"version":3,"file":"main.es.js","sources":["../../src/utils/point.ts","../../src/utils/cellSet.ts","../../src/utils/h/svgTags.ts","../../src/utils/h/index.ts","../../src/utils/array.ts","../../src/generators/_pathSetGenerator.ts","../../src/generators/utils.ts","../../src/generators/index.ts","../../src/generators/recursiveBackTrack.ts","../../src/generators/aldousBroder.ts","../../src/generators/binaryTree.ts","../../src/generators/eller.ts","../../src/generators/kruskal.ts","../../src/generators/huntAndKill.ts","../../src/generators/primsRandomization.ts","../../src/generators/wilson.ts","../../src/generators/sidewinder.ts","../../src/board/cell.ts","../../src/board/board.ts","../../src/board/_.ts","../../src/renderers/rectangularSvg.tsx","../../src/renderers/index.ts","../../src/player/index.ts","../../src/main.ts","../../src/game/index.ts","../../src/browser/element/index.ts","../../src/browser/keyboard/index.ts","../../src/browser/touch/index.ts"],"sourcesContent":["export interface Position {\n  readonly x: number;\n  readonly y: number;\n}\n\n/**\n * Convert a position (2d) to linear index\n */\nexport function positionToIndex(position: Position, width: number): number {\n  return position.y * width + position.x;\n}\n\nexport function stringifyPosition(position: Position) {\n  return `${position.x}-${position.y}`;\n}\n","import {Cell} from \"../board\";\nimport {stringifyPosition} from \"./point\";\n\nexport class CellSet extends Map<string, Cell> {\n  constructor(cells?: Cell[]) {\n    super();\n\n    if (cells) this.addAll(cells);\n  }\n\n  add(cell: Cell) {\n    return this.set(stringifyPosition(cell.position), cell);\n  }\n\n  addAll(cells: Cell[]) {\n    for (let cell of cells)\n      this.add(cell);\n  }\n\n  hasCell(cell: Cell) {\n    return this.has(stringifyPosition(cell.position));\n  }\n\n  remove(cell: Cell) {\n    return this.delete(stringifyPosition(cell.position));\n  }\n\n  removeAll(cells: Cell[]) {\n    for (let cell of cells)\n      this.remove(cell);\n  }\n\n  getRandom(): Cell {\n    const cells = Array.from(this.values());\n    return cells[Math.round(Math.random() * (cells.length -1))];\n  }\n}\n","export default [\"circle\", \"defs\", \"ellipse\", \"filter\", \"g\", \"line\", \"path\", \"rect\", \"svg\"]\n","/*\n * Adopted from https://github.com/squidfunk/mkdocs-material/blob/master/src/assets/javascripts/utilities/h/index.ts\n * with additional support for svg elements\n */\n\nimport {JSX as JSXInternal} from \"preact\"\nimport svgTags from \"./svgTags\";\n\ntype Child =\n  | HTMLElement\n  | Text\n  | string\n  | number\n\ntype Attributes =\n  & JSXInternal.HTMLAttributes\n  & JSXInternal.SVGAttributes\n  & Record<string, any>\n\n\n/**\n * Append a child node to an element\n *\n * @param el - Element\n * @param child - Child node(s)\n */\nfunction appendChild(el: HTMLElement | SVGElement, child: Child | Child[]): void {\n  /* Handle primitive types (including raw HTML) */\n  if (typeof child === \"string\" || typeof child === \"number\") {\n    el.innerHTML += child.toString()\n\n    /* Handle nodes */\n  } else if (child instanceof Node) {\n    el.appendChild(child)\n\n    /* Handle nested children */\n  } else if (Array.isArray(child)) {\n    for (const node of child)\n      appendChild(el, node)\n  }\n}\n\n/**\n * JSX factory\n *\n * @param tag - HTML tag\n * @param attributes - HTML attributes\n * @param children - Child elements\n *\n * @returns Element\n */\nexport function h(\n  tag: string, attributes: Attributes | null, ...children: Child[]\n): HTMLElement | SVGElement {\n  let el;\n\n  /* Handle svg element */\n  if (svgTags.includes(tag)) {\n    el = document.createElementNS(\"http://www.w3.org/2000/svg\", tag);\n\n    /* Handle normal html element */\n  } else {\n    el = document.createElement(tag);\n  }\n\n  /* Set attributes, if any */\n  if (attributes) {\n    for (const attr of Object.keys(attributes)) {\n      if (typeof attributes[attr] !== \"boolean\") {\n        el.setAttribute(attr, attributes[attr]);\n      } else if (attributes[attr]) {\n        el.setAttribute(attr, \"\");\n      }\n    }\n  }\n\n  /* Append child nodes */\n  for (const child of children) {\n    appendChild(el, child)\n  }\n\n  /* Return element */\n  return el\n}\n\n\n/* This override is necessary for types to work */\nexport declare namespace h {\n  namespace JSX {\n    type Element = HTMLElement\n    type IntrinsicElements = JSXInternal.IntrinsicElements\n  }\n}\n","export function shuffle(array: any[]) {\n  let currentIndex = array.length, temporaryValue, randomIndex;\n\n  // While there remain elements to shuffle...\n  while (0 !== currentIndex) {\n\n    // Pick a remaining element...\n    randomIndex = Math.floor(Math.random() * currentIndex);\n    currentIndex -= 1;\n\n    // And swap it with the current element.\n    temporaryValue = array[currentIndex];\n    array[currentIndex] = array[randomIndex];\n    array[randomIndex] = temporaryValue;\n  }\n\n  return array;\n}\n","import {Cell} from \"../board\";\nimport {CellSet} from \"../utils/cellSet\";\nimport set = Reflect.set;\n\nexport type PathSet = Record<string, Cell>;\n\nexport abstract class PathSetGenerator {\n  protected getSetFromCell(cell: Cell, pathSets: CellSet[]): CellSet | undefined {\n    for (let set of pathSets) {\n      if (set.hasCell(cell)) {\n        return set;\n      }\n    }\n  }\n\n  protected joinCellSets(cell1: Cell, cell2: Cell, pathSets: CellSet[]) {\n    const set1 = this.getSetFromCell(cell1, pathSets);\n    const set2 = this.getSetFromCell(cell2, pathSets);\n\n    if (!set1 && !set2) {\n      pathSets.push(new CellSet([cell1, cell2]));\n    } else if (set1 == null) {\n      set2.add(cell1);\n    } else if (set2 == null) {\n      set1.add(cell2);\n    } else {\n      set1.addAll(Array.from(set2.values()));\n      const i = pathSets.indexOf(set2);\n      pathSets.splice(i, 1);\n    }\n  }\n\n  protected isFromSameSet(cell1: Cell, cell2: Cell, pathSets: CellSet[]) {\n    const set1 = this.getSetFromCell(cell1, pathSets);\n    const set2 = this.getSetFromCell(cell2, pathSets);\n\n    return !!set1 && !!set2 && set1 == set2;\n  }\n}\n","import {Board} from \"../board\";\nimport {stringifyPosition} from \"../utils\";\nimport {CellSet} from \"../utils/cellSet\";\n\nexport function getUnvisitedCell(board: Board, visitedCells: CellSet) {\n  for (let cell of board.cells) {\n    if (!visitedCells.has(stringifyPosition(cell.position))) {\n      return cell;\n    }\n  }\n}\n\nexport function getRandomFrom<T>(list: T[]): T {\n  return list[Math.round(Math.random() * (list.length - 1))];\n}\n\nexport function getRandomInt(min: number, max: number): number {\n  return Math.floor(Math.random() * (max - min) + min);\n}\n","import RecursiveBacktrack from \"./recursiveBackTrack\";\nimport AldousBroder from \"./aldousBroder\";\nimport BinaryTree from \"./binaryTree\";\nimport Eller from \"./eller\";\nimport Kruskal from \"./kruskal\";\nimport HuntAndKill from \"./huntAndKill\";\nimport PrimsRandomization from \"./primsRandomization\";\nimport {Wilson} from \"./wilson\";\nimport {Sidewinder} from \"./sidewinder\";\n\nexport * from './types';\n\nexport const Generators = {\n  RecursiveBackTrack: new RecursiveBacktrack(),\n  AldousBroder: new AldousBroder(),\n  BinaryTree: new BinaryTree(),\n  Eller: new Eller(),\n  Kruskal: new Kruskal(),\n  HuntAndKill: new HuntAndKill(),\n  PrimsRandomization: new PrimsRandomization(),\n  Wilson: new Wilson(),\n  Sidewinder: new Sidewinder(),\n}\n","import {Board, Cell, RectangularDirection} from '../board';\nimport {MazeGenerator} from \"./types\";\nimport {CellSet} from \"../utils/cellSet\";\n\n/**\n * Depth first recursive backtrack maze generation algorithm\n * https://weblog.jamisbuck.org/2010/12/27/maze-generation-recursive-backtracking\n *\n * Generates long dead ends making the solution little difficult\n */\nexport default class RecursiveBacktrack implements MazeGenerator {\n  generate(board: Board): Board {\n    board = board.clone();\n\n    // open top-left and bottom-right walls\n    board.cells[0].removeWall(RectangularDirection.LEFT);\n    board.cells[board.cells.length - 1].removeWall(RectangularDirection.RIGHT);\n\n    // select a random cell and start from that cell\n    const visitedCells = new CellSet();\n    const randomCell = board.getRandomCell();\n\n    this.visitCell(randomCell, visitedCells, board);\n    return board;\n  }\n\n  visitCell(cell: Cell, visitedCells: CellSet, board: Board) {\n    visitedCells.add(cell);\n    const neighbourCells = Array.from(board.getNeighbourCells(cell.position).values());\n\n    while (neighbourCells.length !== 0) {\n      // select a random neighbour\n      const i = Math.round(Math.random() * (neighbourCells.length - 1));\n      const randomCell = neighbourCells[i];\n\n      // if random neighbour is not already visited remove wall between\n      // random neighbour and current cell and recursively visit that neighbour\n      if (!visitedCells.hasCell(randomCell)) {\n        board.removeInterWall(cell.position, randomCell.position);\n        this.visitCell(randomCell, visitedCells, board);\n      }\n\n      // after visit remove random neighbour from neighbourCells\n      neighbourCells.splice(i, 1);\n    }\n  }\n}\n","import {Board, RectangularDirection} from '../board';\nimport {MazeGenerator} from \"./types\";\nimport {CellSet} from \"../utils/cellSet\";\n\n/**\n * https://weblog.jamisbuck.org/2011/1/17/maze-generation-aldous-broder-algorithm\n */\nexport default class AldousBroder implements MazeGenerator {\n  generate(board: Board): Board {\n    board = board.clone();\n\n    // open top-left and bottom-right walls\n    board.cells[0].removeWall(RectangularDirection.LEFT);\n    board.cells[board.cells.length - 1].removeWall(RectangularDirection.RIGHT);\n\n    // select a random cell and start from that cell\n    let currentCell = board.getRandomCell();\n    const visitedCells = new CellSet();\n    visitedCells.add(currentCell);\n\n    let movingTowards;\n\n    while (visitedCells.size < board.size.height * board.size.width) {\n      const cellNeighbours = Array.from(board.getNeighbourCells(currentCell.position).values());\n\n      const unvisitedNeighbours = cellNeighbours.filter((cell) => {\n        return !visitedCells.hasCell(cell);\n      })\n\n      // If there are some unvisited neighbours choose any random neighbour and visit it\n      if (unvisitedNeighbours.length > 0) {\n        let randomCell = cellNeighbours[Math.round((cellNeighbours.length - 1) * Math.random())];\n        if (!visitedCells.hasCell(randomCell)) {\n          board.removeInterWall(randomCell.position, currentCell.position)\n          visitedCells.add(randomCell);\n          movingTowards = null;\n        }\n\n        currentCell = randomCell;\n      } else {\n        // else just find random unvisited cell and move towards that cell\n        // until you hit some cell which has some unvisited neighbours\n        // NOTE: its not from actual algorithm but doing make this algorithm to always end in finite time\n\n        if (!movingTowards) {\n          const unvisitedCells = board.cells.filter((cell) => {\n            return !visitedCells.hasCell(cell);\n          });\n\n          movingTowards = unvisitedCells[Math.round((unvisitedCells.length - 1) * Math.random())]\n        }\n\n        let dx = Math.sign(movingTowards.position.x - currentCell.position.x);\n        let dy = dx === 0 ? Math.sign(movingTowards.position.y - currentCell.position.y) : 0;\n        currentCell = board.getCell({x: currentCell.position.x + dx, y: currentCell.position.y + dy});\n      }\n    }\n\n    return board;\n  }\n}\n","import {Board, RectangularDirection} from '../board';\nimport {MazeGenerator} from \"./types\";\n\n/**\n * http://weblog.jamisbuck.org/2011/2/1/maze-generation-binary-tree-algorithm\n */\nexport default class BinaryTree implements MazeGenerator {\n  generate(board: Board): Board {\n    board = board.clone();\n\n    // open top-left and bottom-right walls\n    board.cells[0].removeWall(RectangularDirection.LEFT);\n    board.cells[board.cells.length - 1].removeWall(RectangularDirection.RIGHT);\n\n    const topBias = Math.random() > 0.5;\n    const rightBias = Math.random() > 0.5;\n\n    for (let currentCell of board.cells) {\n      let neighbourCells = Array.from(board.getNeighbourCells(currentCell.position).values());\n      neighbourCells = neighbourCells.filter((cell) => {\n        const dir = board.getRelativeDirection(currentCell.position, cell.position);\n\n        return (rightBias && dir == RectangularDirection.LEFT) ||\n          (!rightBias && dir == RectangularDirection.RIGHT) ||\n          (topBias && dir == RectangularDirection.DOWN) ||\n          (!topBias && dir == RectangularDirection.UP);\n      });\n\n      if (neighbourCells.length > 0) {\n        const randomCell = neighbourCells[Math.round((neighbourCells.length - 1) * Math.random())];\n        board.removeInterWall(randomCell.position, currentCell.position)\n      }\n    }\n\n    return board;\n  }\n}\n","import {Board, RectangularDirection} from '../board';\nimport {MazeGenerator} from \"./types\";\nimport {shuffle} from \"../utils\";\nimport {PathSetGenerator} from \"./_pathSetGenerator\";\nimport {CellSet} from \"../utils/cellSet\";\n\n/**\n * https://weblog.jamisbuck.org/2010/12/29/maze-generation-eller-s-algorithm\n */\nexport default class Eller extends PathSetGenerator implements MazeGenerator {\n  generate(board: Board): Board {\n    board = board.clone();\n\n    // open top-left and bottom-right walls\n    board.cells[0].removeWall(RectangularDirection.LEFT);\n    board.cells[board.cells.length - 1].removeWall(RectangularDirection.RIGHT);\n\n    const pathSets: CellSet[] = [];\n\n    for (let x = 0; x < board.size.width; x++) {\n      const cell = board.getCell({x, y: 0});\n      pathSets.push(new CellSet([cell]));\n    }\n\n    for (let y = 0; y < board.size.height - 1; y++) {\n      this.visitRow(y, false, board, pathSets);\n      this.visitNextRow(y, board, pathSets);\n    }\n\n    this.visitRow(board.size.height - 1, true, board, pathSets);\n    return board;\n  }\n\n  private visitRow(index: number, mergeAll: boolean, board: Board, pathSets: CellSet[]) {\n    for (let x = 1; x < board.size.width; x++) {\n      const cell1 = board.getCell({y: index, x: x - 1});\n      const cell2 = board.getCell({y: index, x});\n\n      if (this.isFromSameSet(cell1, cell2, pathSets)) {\n        continue;\n      }\n\n      if (Math.random() > 0.5 || mergeAll) {\n        board.removeInterWall(cell1.position, cell2.position);\n        this.joinCellSets(cell1, cell2, pathSets);\n      } else if (this.getSetFromCell(cell1, pathSets) == null) {\n        pathSets.push(new CellSet([cell1]));\n      } else if (this.getSetFromCell(cell2, pathSets) == null) {\n        pathSets.push(new CellSet([cell2]));\n      }\n    }\n  }\n\n  private visitNextRow(index: number, board: Board, pathSets: CellSet[]) {\n    for (let set of pathSets) {\n      let setCells = Array.from(set.entries())\n        .filter(([key, cell]) => {\n          return cell.position.y === index;\n        })\n        .map(([key, cell]) => cell);\n\n      setCells = shuffle(setCells);\n      let n = 1 + Math.round(Math.random() * (setCells.length - 1));\n      for (let i = 0; i < n; i++) {\n        const cell = setCells[i];\n        const nextCell = board.getCell({x: cell.position.x, y: cell.position.y + 1});\n\n        board.removeInterWall(cell.position, nextCell.position);\n        set.add(nextCell);\n      }\n    }\n  }\n}\n","import {Board, RectangularDirection} from '../board';\nimport {MazeGenerator} from \"./types\";\nimport {PathSetGenerator} from \"./_pathSetGenerator\";\nimport {CellSet} from \"../utils/cellSet\";\n\n/**\n * https://weblog.jamisbuck.org/2011/1/3/maze-generation-kruskal-s-algorithm\n */\nexport default class Kruskal extends PathSetGenerator implements MazeGenerator {\n  generate(board: Board): Board {\n    board = board.clone();\n\n    // open top-left and bottom-right walls\n    board.cells[0].removeWall(RectangularDirection.LEFT);\n    board.cells[board.cells.length - 1].removeWall(RectangularDirection.RIGHT);\n\n    const pathSets: CellSet[] = [];\n\n    for (let cell of board.cells) {\n      pathSets.push(new CellSet([cell]));\n    }\n\n    while (pathSets.length > 1) {\n      const randomCell = board.getRandomCell();\n      const neighbours = Array.from(board.getNeighbourCells(randomCell.position).values());\n      const randomNeighbour = neighbours[Math.round((neighbours.length - 1) * Math.random())]\n\n      if (this.isFromSameSet(randomCell, randomNeighbour, pathSets)) continue;\n\n      board.removeInterWall(randomCell.position, randomNeighbour.position);\n      this.joinCellSets(randomCell, randomNeighbour, pathSets);\n    }\n\n    return board;\n  }\n}\n","import {Board, Cell, RectangularDirection} from '../board';\nimport {MazeGenerator} from \"./types\";\nimport {stringifyPosition} from \"../utils\";\nimport {PathSetGenerator} from \"./_pathSetGenerator\";\nimport {getUnvisitedCell} from \"./utils\";\nimport {CellSet} from \"../utils/cellSet\";\n\n/**\n * https://weblog.jamisbuck.org/2011/1/24/maze-generation-hunt-and-kill-algorithm\n */\nexport default class HuntAndKill extends PathSetGenerator implements MazeGenerator {\n  generate(board: Board): Board {\n    board = board.clone();\n\n    // open top-left and bottom-right walls\n    board.cells[0].removeWall(RectangularDirection.LEFT);\n    board.cells[board.cells.length - 1].removeWall(RectangularDirection.RIGHT);\n\n    // select a random cell and start from that cell\n    const visitedCells = new CellSet();\n    let cell = getUnvisitedCell(board, visitedCells);\n\n    while (cell) {\n      const neighbourCells = Array.from(board.getNeighbourCells(cell.position).values());\n      for (let neighbourCell of neighbourCells) {\n        if (visitedCells.has(stringifyPosition(neighbourCell.position))) {\n          board.removeInterWall(cell.position, neighbourCell.position);\n          break;\n        }\n      }\n\n      this.randomWalk(cell, board, visitedCells);\n      cell = getUnvisitedCell(board, visitedCells);\n    }\n\n    return board;\n  }\n\n  private randomWalk(cell: Cell, board: Board, visitedCells: CellSet) {\n    visitedCells.add(cell);\n\n    let neighbourCells = Array.from(board.getNeighbourCells(cell.position).values());\n    neighbourCells = neighbourCells.filter((cell) => {\n      return !visitedCells.hasCell(cell);\n    });\n    if (neighbourCells.length === 0) return;\n\n    const randomCell = neighbourCells[Math.round(Math.random() * (neighbourCells.length - 1))];\n    if (!visitedCells.hasCell(randomCell)) {\n      board.removeInterWall(cell.position, randomCell.position);\n      visitedCells.add(randomCell);\n\n      this.randomWalk(randomCell, board, visitedCells);\n    }\n  }\n}\n","import {Board, RectangularDirection} from '../board';\nimport {MazeGenerator} from \"./types\";\nimport {CellSet} from \"../utils/cellSet\";\n\n/**\n * Prim's Randomization Algorithm\n * http://weblog.jamisbuck.org/2011/1/10/maze-generation-prim-s-algorithm\n *\n * Generates relatively easy to solve mazes with short dead ends\n */\nexport default class PrimsRandomization implements MazeGenerator {\n  generate(board: Board): Board {\n    board = board.clone();\n\n    // open top-left and bottom-right walls\n    board.cells[0].removeWall(RectangularDirection.LEFT);\n    board.cells[board.cells.length - 1].removeWall(RectangularDirection.RIGHT);\n\n    // select a random cell and start from that cell\n    const visitedCells = new CellSet();\n    let randomCell = board.getRandomCell();\n    const neighbourCells = new CellSet(Array.from(board.getNeighbourCells(randomCell.position).values()));\n\n    visitedCells.add(randomCell);\n\n    while (neighbourCells.size > 0) {\n      randomCell = neighbourCells.getRandom();\n      const randomCellNeighbours = new CellSet(Array.from(board.getNeighbourCells(randomCell.position).values()));\n\n      for (let randomCellNeighbour of randomCellNeighbours.values()) {\n        if (visitedCells.hasCell(randomCellNeighbour)) {\n          board.removeInterWall(randomCellNeighbour.position, randomCell.position);\n\n          neighbourCells.remove(randomCell);\n          visitedCells.add(randomCell);\n          neighbourCells.addAll(Array.from(randomCellNeighbours.values()));\n          neighbourCells.removeAll(Array.from(visitedCells.values()));\n          break;\n        }\n      }\n    }\n\n    return board;\n  }\n}\n","import {MazeGenerator} from \"./types\";\nimport {Board, Cell, RectangularDirection} from \"../board\";\nimport {CellSet} from \"../utils/cellSet\";\nimport {getRandomFrom, getUnvisitedCell} from \"./utils\";\n\n/**\n * Wilson's Maze Generation Algorithm\n * https://weblog.jamisbuck.org/2011/1/20/maze-generation-wilson-s-algorithm\n *\n * It unlike many other algorithms generate generate mazes of unbiased complexity\n */\nexport class Wilson implements MazeGenerator {\n  generate(board: Board): Board {\n    board = board.clone();\n\n    // open top-left and bottom-right walls\n    board.cells[0].removeWall(RectangularDirection.LEFT);\n    board.cells[board.cells.length - 1].removeWall(RectangularDirection.RIGHT);\n\n    const visitedCells = new CellSet();\n    visitedCells.add(board.getRandomCell());\n\n    while (visitedCells.size < board.size.height * board.size.width) {\n      let randomCell = getUnvisitedCell(board, visitedCells);\n      let path: Cell[] = [randomCell];\n\n      while (!visitedCells.hasCell(randomCell)) {\n        // TODO: getNeighbourCells\n        const neighbourCells = Array.from(board.getNeighbourCells(randomCell.position).values());\n        randomCell = getRandomFrom(neighbourCells);\n\n        if (path.includes(randomCell)) {\n          path = path.slice(0, path.indexOf(randomCell));\n\n        }\n        path.push(randomCell);\n      }\n\n      for (let i = 1; i < path.length; i++) {\n        board.removeInterWall(path[i - 1].position, path[i].position);\n      }\n\n      visitedCells.addAll(path);\n    }\n\n    return board;\n  }\n\n}\n","import {MazeGenerator} from \"./types\";\nimport {Board, RectangularDirection} from \"../board\";\nimport {getRandomInt} from \"./utils\";\n\n/**\n * https://weblog.jamisbuck.org/2011/2/3/maze-generation-sidewinder-algorithm#\n */\nexport class Sidewinder implements MazeGenerator {\n  generate(board: Board): Board {\n    board = board.clone();\n\n    // open top-left and bottom-right walls\n    board.cells[0].removeWall(RectangularDirection.LEFT);\n    board.cells[board.cells.length - 1].removeWall(RectangularDirection.RIGHT);\n\n    for (let x = 1; x < board.size.width; x++) {\n      board.removeInterWall({y: 0, x: x}, {y: 0, x: x-1})\n    }\n\n    for (let y = 1; y < board.size.height; y++) {\n      this.visitRow(y, board);\n    }\n\n    return board;\n  }\n\n  private visitRow(y: number, board: Board) {\n    let joinedCells = 0;\n    for (let x = 1; x < board.size.width; x++) {\n      if (Math.random() > .5) {\n        board.removeInterWall({y, x: x - 1}, {y, x})\n        joinedCells++;\n      } else {\n        const h = getRandomInt(x - 1 - joinedCells, x);\n        board.removeInterWall({y, x: h}, {y: y - 1, x: h})\n        joinedCells = 0;\n      }\n    }\n\n    const h = getRandomInt(board.size.width - joinedCells - 1, board.size.width);\n    board.removeInterWall({y, x: h}, {y: y - 1, x: h})\n  }\n}\n","import {Position} from \"../utils\";\n\nexport const enum RectangularDirection {\n  LEFT = 'left',\n  RIGHT = 'right',\n  UP = 'up',\n  DOWN = 'down',\n}\n\nexport const OpposingRectangularDirection = {\n  [RectangularDirection.LEFT]: RectangularDirection.RIGHT,\n  [RectangularDirection.RIGHT]: RectangularDirection.LEFT,\n  [RectangularDirection.UP]: RectangularDirection.DOWN,\n  [RectangularDirection.DOWN]: RectangularDirection.UP,\n};\n\nexport class Cell {\n  public readonly walls: Map<RectangularDirection, boolean>;\n\n  constructor(public readonly position: Position) {\n    this.walls = new Map<RectangularDirection, boolean>();\n    this.setAllWalls();\n  }\n\n  setAllWalls() {\n    this.setWall(RectangularDirection.UP);\n    this.setWall(RectangularDirection.RIGHT);\n    this.setWall(RectangularDirection.DOWN);\n    this.setWall(RectangularDirection.LEFT);\n  }\n\n  removeAllWalls() {\n    this.removeWall(RectangularDirection.UP);\n    this.removeWall(RectangularDirection.RIGHT);\n    this.removeWall(RectangularDirection.DOWN);\n    this.removeWall(RectangularDirection.LEFT);\n  }\n\n  setWall(dir: RectangularDirection) {\n    this.walls.set(dir, true);\n  }\n\n  removeWall(dir: RectangularDirection) {\n    this.walls.set(dir, false);\n  }\n\n  hasWall(dir: RectangularDirection): boolean {\n    return this.walls.get(dir);\n  }\n\n  clone() {\n    const cell = new Cell(this.position);\n    for (const [dir, hasWall] of this.walls.entries()) {\n      cell.walls.set(dir, hasWall);\n    }\n    return cell;\n  }\n}\n","import {Cell, OpposingRectangularDirection, RectangularDirection} from './cell';\nimport {Position, positionToIndex, Size} from \"../utils\";\n\nexport class Board {\n  public readonly cells: Array<Cell>;\n  public readonly size: Size;\n\n  constructor(width: number, height: number) {\n    this.size = {height, width};\n    this.cells = [];\n    this.initCells();\n  }\n\n  private initCells() {\n    for (let y = 0; y < this.size.height; y++) {\n      for (let x = 0; x < this.size.width; x++) {\n        this.cells.push(new Cell({x, y}));\n      }\n    }\n  }\n\n  getRandomCell(): Cell {\n    return this.cells[Math.round(Math.random() * (this.cells.length - 1))];\n  }\n\n  getCell(position: Position): Cell {\n    return this.cells[positionToIndex(position, this.size.width)];\n  }\n\n  getNeighbourCells(position: Position, visitableOnly: boolean = false): Map<RectangularDirection, Cell> {\n    let neighbours = new Map<RectangularDirection, Cell>(),\n      index = positionToIndex(position, this.size.width);\n\n    if (index >= this.size.width) {\n      const cell = this.cells[index - this.size.width];\n      neighbours.set(RectangularDirection.UP, cell);\n    }\n\n    if ((index + 1) % this.size.width != 0) {\n      const cell = this.cells[index + 1];\n      neighbours.set(RectangularDirection.RIGHT, cell);\n    }\n\n    if (index < this.cells.length - this.size.width) {\n      const cell = this.cells[index + this.size.width];\n      neighbours.set(RectangularDirection.DOWN, cell);\n    }\n\n    if (index % this.size.width != 0) {\n      const cell = this.cells[index - 1];\n      neighbours.set(RectangularDirection.LEFT, cell);\n    }\n\n    if (visitableOnly) {\n      const visitableNeighbours = Array.from(neighbours.entries())\n        .filter(([dir, cell]) => {\n          return !this.hasInterWall(cell.position, position);\n        });\n\n      neighbours = new Map(visitableNeighbours);\n    }\n\n    return neighbours;\n  }\n\n  getNeighbourCell(position: Position, direction: RectangularDirection): Cell {\n    const cells = this.getNeighbourCells(position);\n    return cells.get(direction);\n  }\n\n  getRelativeDirection(cell1: Position, cell2: Position): RectangularDirection {\n    if (cell1.y === cell2.y + 1) {\n      return RectangularDirection.UP;\n    }\n    if (cell1.x === cell2.x - 1) {\n      return RectangularDirection.RIGHT;\n    }\n    if (cell1.x === cell2.x + 1) {\n      return RectangularDirection.LEFT;\n    }\n    if (cell1.y === cell2.y - 1) {\n      return RectangularDirection.DOWN;\n    }\n    throw `'${cell1}' and '${cell2}' are not neighbours`;\n  }\n\n  removeInterWall(cell1: Position, cell2: Position): void {\n    const relativeWallDirection = this.getRelativeDirection(cell1, cell2);\n    const opposingWallDirection = OpposingRectangularDirection[relativeWallDirection];\n    this.getCell(cell1).removeWall(relativeWallDirection);\n    this.getCell(cell2).removeWall(opposingWallDirection);\n  }\n\n  addInterWall(cell1: Position, cell2: Position): void {\n    const relativeWallDirection = this.getRelativeDirection(cell1, cell2);\n    const opposingWallDirection = OpposingRectangularDirection[relativeWallDirection];\n    this.getCell(cell1).setWall(relativeWallDirection);\n    this.getCell(cell2).setWall(opposingWallDirection);\n  }\n\n  hasInterWall(cell1: Position, cell2: Position): boolean {\n    const relativeWall = this.getRelativeDirection(cell1, cell2);\n    const opposingWall = OpposingRectangularDirection[relativeWall];\n    return this.getCell(cell1).hasWall(relativeWall) && this.getCell(cell2).hasWall(opposingWall);\n  }\n\n  isConnected(cell1: Position, cell2: Position): Boolean {\n    const relativeWallDirection = this.getRelativeDirection(cell1, cell2);\n    const opposingWallDirection = OpposingRectangularDirection[relativeWallDirection];\n    return this.getCell(cell1).hasWall(relativeWallDirection) && this.getCell(cell2).hasWall(opposingWallDirection);\n  }\n\n  hasWall(position: Position, direction: RectangularDirection) {\n    return this.getCell(position).hasWall(direction);\n  }\n\n  clone() {\n    const board = new Board(this.size.width, this.size.height);\n    for (let i = 0; i < board.cells.length; i++) {\n      board.cells[i] = this.cells[i].clone();\n    }\n    return board;\n  }\n}\n","import {BehaviorSubject, Observable} from \"rxjs\";\nimport {Board} from \"./board\";\nimport {concatMap, filter, share} from \"rxjs/operators\";\nimport {MazeGenerator} from \"../generators\";\nimport {Position} from \"../utils\";\n\n/*--------------\n * Interfaces\n *-------------- */\n\nexport interface BoardOptions {\n  width: number;\n  height: number;\n  generator: MazeGenerator,\n}\n\n/*-------------------\n * Reactive instance\n *------------------- */\n\nconst board$ = new BehaviorSubject<BoardOptions>(null)\n\n\n/*-------------------\n * Actions\n *------------------- */\n\n/**\n * Reset board with last board settings\n */\nexport function resetBoard() {\n  board$.next(board$.getValue());\n}\n\n/**\n * generate a new board with given board `options`\n */\nexport function newBoard(options: BoardOptions) {\n  board$.next(options);\n}\n\n/*-------------------\n * Helpers\n *------------------- */\n\n/**\n * Checks if the given position is last position of cell\n * useful to test game win state\n */\nexport function isLastCell({x, y}: Position): boolean {\n  const {width, height} = board$.getValue();\n  return x === width - 1 && y === height - 1;\n}\n\n/*-------------------\n * Functions\n *------------------- */\n\nexport function mountBoard(): Observable<Board> {\n  return board$\n    .pipe(\n      filter(ev => !!ev),\n      concatMap(async ({width, height, generator}) => {\n        let board = new Board(width, height);\n        return generator.generate(board);\n      }),\n      share(),\n    );\n}\n","import {h} from \"../utils\";\nimport {IRenderer} from \"./types\";\nimport {Board, Cell, RectangularDirection} from \"../board\";\nimport {Observable} from \"rxjs\";\nimport {Player} from \"../player\";\n\nexport default class RectangularSvg implements IRenderer {\n  /*\n   * Some rendering options\n   * should some easier way to set them\n   */\n  public cellSize = 30;\n  public lineWidth = 2;\n  public playerPadding = 7;\n\n  constructor() {\n    // setting a css variable for wall animation\n    let root = document.documentElement;\n    root.style.setProperty('--cell-size', this.cellSize + 'px');\n  }\n\n  /**\n   * Renders game board to svg\n   *\n   * The idea is renderer will be initialized only once\n   * and then render function will be called for each new board,\n   * while renderer will take care of player changes without explicitly\n   * rerendering of board.\n   *\n   * @param board individual board snapshot\n   * @param player$ Observable of player position changes\n   */\n  render(board: Board, player$: Observable<Player>): HTMLElement {\n    const width = this.cellSize * (board.size.width + 2) + this.lineWidth;\n    const height = this.cellSize * (board.size.height + 2) + this.lineWidth;\n    const playerEl = this.renderPlayer();\n\n    // listen to player changes and update player on board\n    player$\n      .subscribe(({position}) => {\n        const [x, y] = [position.x, position.y]\n          .map((e) => (this.cellSize * e) + this.playerPadding + this.cellSize);\n\n        playerEl.setAttribute('x', x + '');\n        playerEl.setAttribute('y', y + '');\n      })\n\n    // render path definition string for each cell\n    // and join them to create single path string\n    // for whole board\n    let path = board.cells.map((value) => {\n      return this.renderCell(value, board.size);\n    }).join('');\n\n    return (\n      <svg stroke=\"currentColor\" fill=\"none\" width={width} height={height} viewBox={`0 0 ${width} ${height}`}>\n        {playerEl}\n        <path d={path} class=\"maze-wall\" stroke-width={this.lineWidth} stroke-linecap=\"round\"/>\n      </svg>\n    );\n  }\n\n  /**\n   * Renders player as svg rect\n   */\n  renderPlayer() {\n    const size = this.cellSize - (this.playerPadding * 2);\n    return <rect width={size} height={size} fill=\"currentColor\"\n                 class=\"text-blue-500\"\n                 stroke-width=\"0\" rx=\"3\" id=\"player\"\n                 x={1 + this.playerPadding + this.cellSize} y={1 + this.playerPadding + this.cellSize}/>;\n  }\n\n  /**\n   * Renders a single cell walls to svg path string\n   * @param cell cell to render\n   * @param size board size\n   */\n  renderCell(cell: Cell, size: { width: number, height: number }): string {\n    const pivotX = cell.position.x * this.cellSize + (this.lineWidth / 2) + this.cellSize;\n    const pivotY = cell.position.y * this.cellSize + (this.lineWidth / 2) + this.cellSize;\n    let path = '';\n\n    if (cell.hasWall(RectangularDirection.UP)) {\n      // Top wall\n      path += `M${pivotX},${pivotY}H${pivotX + this.cellSize}`;\n    }\n\n    if (cell.hasWall(RectangularDirection.LEFT)) {\n      // Left wall\n      path += `M${pivotX},${pivotY}V${pivotY + this.cellSize}`;\n    }\n\n    if (cell.position.x + 1 === size.width && cell.hasWall(RectangularDirection.RIGHT)) {\n      // Right Wall\n      path += `M${pivotX + this.cellSize},${pivotY}V${pivotY + this.cellSize}`;\n    }\n\n    if (cell.position.y + 1 === size.height) {\n      // Bottom Wall\n      path += `M${pivotX},${pivotY + this.cellSize}H${pivotX + this.cellSize}`;\n    }\n\n    return path;\n  }\n}\n","import {IRenderer} from \"./types\";\nimport RectangularSvg from './rectangularSvg';\n\nexport enum Renderers {\n  rectangularSvg\n}\n\nclass RendererManager {\n  private renderers = new Map<Renderers, IRenderer>();\n\n  async loadRenderer(name: Renderers) {\n    if (this.renderers.has(name)) {\n      return this.renderers.get(name);\n    }\n\n    // Just easiest work around for rollup dynamic imports\n    let module;\n    switch (name) {\n      case Renderers.rectangularSvg:\n        module = RectangularSvg;\n        break;\n    }\n\n    const renderer = new module();\n    this.renderers.set(name, renderer);\n    return renderer;\n  }\n}\n\nexport default new RendererManager();\n","import {animationFrameScheduler, BehaviorSubject, merge, Observable} from \"rxjs\";\nimport {Keyboard, Swipe} from \"../browser\";\nimport {Board, RectangularDirection} from \"../board\";\nimport {Position} from \"../utils\";\nimport {filter, map, observeOn, withLatestFrom} from \"rxjs/operators\";\n\n/*------------------\n * Types\n *------------------*/\n\nexport interface MountOptions {\n  keyboard$: Observable<Keyboard>;\n  swipe$: Observable<Swipe>;\n  board$: Observable<Board>;\n}\n\nexport interface Player {\n  state: 'active' | 'inactive' | 'hidden';\n  position: Position;\n}\n\nexport interface Control {\n  dir: RectangularDirection\n}\n\n/*------------------\n * Maps\n *------------------*/\n\nexport const keyMap = {\n  'ArrowRight': RectangularDirection.RIGHT,\n  'ArrowLeft': RectangularDirection.LEFT,\n  'ArrowUp': RectangularDirection.UP,\n  'ArrowDown': RectangularDirection.DOWN,\n}\n\n/*--------------------\n * Reactive instance\n *--------------------*/\n\nconst player$ = new BehaviorSubject<Player>({\n  state: 'active',\n  position: {x: 0, y: 0}\n});\n\n\n/*--------------------\n * Actions\n *--------------------*/\n\n/**\n * Set player Position\n */\nexport function setPlayerPosition(position: Position) {\n  const {state} = player$.getValue();\n  player$.next({\n    state,\n    position,\n  })\n}\n\n/**\n * Set player Position\n */\nexport function setPlayerState(state: 'active' | 'inactive' | 'hidden') {\n  const {position} = player$.getValue();\n  player$.next({\n    state,\n    position,\n  })\n}\n\n/**\n * Move player in given direction\n */\nexport function moveInDirection(dir: RectangularDirection, board: Board) {\n  let {position: {x, y}} = player$.getValue();\n\n  // continue to moving player in the direction until cell is a passage\n  do {\n    if (dir === 'right' && x < (board.size.width - 1)) {\n      x++;\n    } else if (dir === 'left' && x > 0) {\n      x--;\n    } else if (dir === 'up' && y > 0) {\n      y--;\n    } else if (dir === 'down' && y < (board.size.height - 1)) {\n      y++;\n    }\n\n    const visitable = board.getNeighbourCells({x, y}, true);\n    if (!visitable.has(dir) || visitable.size > 2) {\n      break;\n    }\n  } while (true);\n\n  setPlayerPosition({x, y});\n}\n\n/*--------------------\n * Functions\n *--------------------*/\n\n/**\n * Mount player to game logic\n *\n * returns a observable player\n */\nexport function mountPlayer(\n  {keyboard$, swipe$, board$}: MountOptions\n): Observable<Player> {\n\n  // reset player whenever new board is emitted\n  board$.subscribe(() => {\n    const {position: {x, y}} = player$.getValue();\n    if (x !== 0 || y !== 0) {\n      setPlayerPosition({x: 0, y: 0})\n    }\n  })\n\n  // combine touch and keyboard events\n  const control$: Observable<Control> = merge(\n    keyboard$,\n    swipe$,\n  ).pipe(\n    map((dir) => {\n      if ((dir as Keyboard).type) {\n        // @ts-ignore\n        return {dir: keyMap[dir.type]}\n      }\n      return dir as Swipe;\n    })\n  )\n\n  control$\n    .pipe(\n      withLatestFrom(board$),\n      // don't move player if there is a wall in control direction\n      // or player is not active\n      filter(([{dir}, board]) => {\n        const {position: {x, y}, state} = player$.getValue();\n        return state === 'active' && !board.hasWall({x, y}, dir);\n      })\n    )\n    .subscribe(([{dir}, board]) => {\n      moveInDirection(dir, board)\n    });\n\n  // use animationFrameScheduler to ensure smooth animations\n  return player$.pipe(\n    observeOn(animationFrameScheduler)\n  )\n}\n","import {watchKeyboard, watchSwipe} from \"./browser\";\nimport {Generators} from './generators';\nimport {newBoard, resetBoard} from \"./board\";\nimport {fromEvent} from \"rxjs\";\nimport {mountGame} from \"./game\";\n\n/*\n * References to some required document elements\n * Technically this should be done after DOM Content Loaded\n * But for some reason its working :)\n */\nconst boardEl = document.getElementById('board');\nconst boardWrapperEl = document.getElementById('boardWrapper');\nconst ResetEl = document.getElementById('reset');\n\n\n/* initialize all the observables */\nconst keyboard$ = watchKeyboard();\nconst swipe$ = watchSwipe(boardWrapperEl);\n\nmountGame({keyboard$, swipe$, boardEl});\n\n/*\n * Initialize board with initial options.\n * Every other price of the board depends on\n * some non-null value of board option\n */\nnewBoard({\n  height: 15,\n  width: 15,\n  generator: Generators.RecursiveBackTrack,\n});\n\n\n/* Bind events with buttons */\nfromEvent(ResetEl, 'click')\n  .subscribe(resetBoard);\n","import {Size} from \"../utils\";\nimport {MazeGenerator} from \"../generators\";\nimport renderersManager, {Renderers} from \"../renderers\";\nimport {Observable} from \"rxjs\";\nimport {Keyboard} from \"../browser/keyboard\";\nimport {Swipe} from \"../browser/touch\";\nimport {isLastCell, mountBoard, resetBoard} from \"../board\";\nimport {mountPlayer, setPlayerPosition, setPlayerState} from \"../player\";\nimport {removeElementChildren} from \"../browser/element\";\nimport {filter} from \"rxjs/operators\";\nimport {default as canvasConfetti} from \"canvas-confetti\";\n\nexport interface GameOptions {\n  size: Size;\n  generator: MazeGenerator;\n  renderer: Renderers;\n  interactive: boolean;\n  showPlayer: boolean;\n}\n\ninterface MountOptions {\n  keyboard$: Observable<Keyboard>;\n  swipe$: Observable<Swipe>;\n  boardEl: HTMLElement;\n}\n\n/**\n * Handle keyboard shortcuts\n */\nfunction registerShortcuts(keyboard$: Observable<Keyboard>) {\n  keyboard$.subscribe(({type}) => {\n    /* 'r' to reset game */\n    if (type.toLowerCase() === 'r') {\n      resetBoard();\n    }\n  })\n}\n\nexport function mountGame({keyboard$, swipe$, boardEl}: MountOptions) {\n  registerShortcuts(keyboard$);\n\n  const board$ = mountBoard();\n  const player$ = mountPlayer({keyboard$, board$, swipe$});\n\n  /* render board whenever new board is emitted */\n  board$\n    .subscribe((board) => {\n      setPlayerState('active');\n      renderersManager.loadRenderer(Renderers.rectangularSvg).then((render) => {\n        removeElementChildren(boardEl);\n        boardEl.appendChild(\n          render.render(board, player$)\n        );\n      })\n    });\n\n  player$\n    .pipe(\n      filter(({position, state}) => isLastCell(position) && state === 'active'),\n    )\n    .subscribe(async ({position: {x, y}}) => {\n      const start = new Date().getTime();\n      setPlayerState('inactive');\n\n      let confetti: typeof canvasConfetti;\n      try {\n        const canvasConfetti = await import('canvas-confetti');\n        confetti = canvasConfetti.default;\n      } catch (e) {\n        console.error(e);\n      }\n\n      const timeDiff = new Date().getTime() - start;\n      if (timeDiff >= 250) {\n        setPlayerPosition({x: x + 1, y});\n\n        if (confetti)\n          confetti({origin: {y: 0.8}, particleCount: 100}).then();\n      } else {\n        setTimeout(() => {\n          setPlayerPosition({x: x + 1, y});\n          if (confetti)\n            confetti({origin: {y: 0.8}, particleCount: 100}).then();\n        }, 250 - timeDiff);\n      }\n    });\n}\n","/**\n * Retrieve the currently active element\n *\n * @returns Element or nothing\n */\nexport function getActiveElement(): HTMLElement | undefined {\n  return document.activeElement instanceof HTMLElement\n    ? document.activeElement\n    : undefined\n}\n\n\n/**\n * Remove all the children of given element\n */\nexport function removeElementChildren(element: HTMLElement): void {\n  while (element.lastElementChild) {\n    element.removeChild(element.lastElementChild);\n  }\n}\n","import {fromEvent, Observable} from \"rxjs\";\nimport {filter, map, share} from \"rxjs/operators\";\nimport {getActiveElement} from \"../element\";\n\n/**\n * Keyboard\n */\nexport interface Keyboard {\n  type: string                         /* Key type */\n  claim(): void                        /* Key claim */\n}\n\n/**\n * Check whether an element may receive keyboard input\n *\n * @param el - Element\n *\n * @returns Test result\n */\nfunction isSusceptibleToKeyboard(el: HTMLElement): boolean {\n  switch (el.tagName) {\n    /* Form elements */\n    case \"INPUT\":\n    case \"SELECT\":\n    case \"TEXTAREA\":\n      return true\n\n    /* Everything else */\n    default:\n      return el.isContentEditable\n  }\n}\n\n/**\n * Watch keyboard\n *\n * @returns Keyboard observable\n */\nexport function watchKeyboard(): Observable<Keyboard> {\n  return fromEvent<KeyboardEvent>(window, \"keydown\")\n    .pipe(\n      filter(ev => !(ev.metaKey || ev.ctrlKey)),\n      map(ev => ({\n        type: ev.key,\n        claim() {\n          ev.preventDefault()\n          ev.stopPropagation()\n        }\n      } as Keyboard)),\n      filter(() => {\n        const active = getActiveElement()\n        if (typeof active !== \"undefined\")\n          return !isSusceptibleToKeyboard(active)\n\n        return true\n      }),\n      share(),\n    )\n}\n","import {from, fromEvent, merge, NEVER, Observable} from \"rxjs\";\nimport {map, share, switchMap} from \"rxjs/operators\";\nimport {RectangularDirection} from \"../../board\";\n\nexport interface Swipe {\n  dir: RectangularDirection;\n}\n\n/**\n * Watch swipe events on the given element using hammerjs\n */\nexport function watchSwipe(element = document.documentElement): Observable<Swipe> {\n  const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0);\n\n  if (!isTouchDevice) {\n    return NEVER;\n  }\n\n  return from(import('hammerjs'))\n    .pipe(\n      switchMap((hammer) => {\n        const mc = new hammer.Manager(element);\n        mc.add(new hammer.Swipe());\n\n        return merge(\n          fromEvent(mc, 'swipeleft'),\n          fromEvent(mc, 'swiperight'),\n          fromEvent(mc, 'swipeup'),\n          fromEvent(mc, 'swipedown'),\n        )\n      }),\n      map(({type}) => {\n        return {dir: type.slice(5)};\n      }),\n      share(),\n    )\n}\n"],"names":["positionToIndex","position","width","y","x","stringifyPosition","CellSet","Map","[object Object]","cells","super","this","addAll","cell","set","add","has","delete","remove","Array","from","values","Math","round","random","length","appendChild","el","child","innerHTML","toString","Node","isArray","node","h","tag","attributes","children","svgTags","includes","document","createElementNS","createElement","attr","Object","keys","setAttribute","shuffle","array","temporaryValue","randomIndex","currentIndex","floor","PathSetGenerator","pathSets","hasCell","cell1","cell2","set1","getSetFromCell","set2","i","indexOf","splice","push","getUnvisitedCell","board","visitedCells","getRandomInt","min","max","Generators","RecursiveBackTrack","clone","removeWall","randomCell","getRandomCell","visitCell","neighbourCells","getNeighbourCells","removeInterWall","AldousBroder","currentCell","movingTowards","size","height","cellNeighbours","filter","unvisitedCells","dx","sign","dy","getCell","BinaryTree","topBias","rightBias","dir","getRelativeDirection","Eller","visitRow","visitNextRow","index","mergeAll","isFromSameSet","joinCellSets","setCells","entries","key","map","n","nextCell","Kruskal","neighbours","randomNeighbour","HuntAndKill","neighbourCell","randomWalk","PrimsRandomization","getRandom","randomCellNeighbours","randomCellNeighbour","removeAll","Wilson","path","list","slice","Sidewinder","joinedCells","OpposingRectangularDirection","left","right","up","down","Cell","walls","setAllWalls","setWall","get","hasWall","Board","initCells","visitableOnly","visitableNeighbours","hasInterWall","direction","relativeWallDirection","opposingWallDirection","relativeWall","opposingWall","board$","BehaviorSubject","resetBoard","next","getValue","isLastCell","mountBoard","pipe","ev","concatMap","async","generator","generate","share","RectangularSvg","documentElement","style","setProperty","cellSize","player$","lineWidth","playerEl","renderPlayer","subscribe","e","playerPadding","value","renderCell","join","stroke","fill","viewBox","d","class","rx","id","pivotX","pivotY","Renderers","name","renderers","module","rectangularSvg","renderer","keyMap","ArrowRight","ArrowLeft","ArrowUp","ArrowDown","state","setPlayerPosition","setPlayerState","mountPlayer","keyboard$","swipe$","merge","type","withLatestFrom","visitable","moveInDirection","observeOn","animationFrameScheduler","boardEl","getElementById","boardWrapperEl","ResetEl","options","toLowerCase","registerShortcuts","renderersManager","loadRenderer","then","render","element","lastElementChild","removeChild","removeElementChildren","start","Date","getTime","confetti","canvasConfetti","import","default","console","error","timeDiff","origin","particleCount","setTimeout","mountGame","fromEvent","window","metaKey","ctrlKey","preventDefault","stopPropagation","active","activeElement","HTMLElement","undefined","tagName","isContentEditable","isSusceptibleToKeyboard","navigator","maxTouchPoints","msMaxTouchPoints","switchMap","hammer","mc","Manager","Swipe","NEVER","watchSwipe"],"mappings":"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"}